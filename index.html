<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>吉吉色色牌 Jiji Color card</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
            background-color: #1f2937;
        }
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: manipulation;
            color: white;
        }
        .hidden {
            display: none !important;
        }
        #title-screen {
            background: url('https://lingamjiji.com/wp-content/uploads/2025/10/gemini_generated_image_3y5f093y5f093y5f.png?q=80&w=2070&auto=format&fit=crop') center center / cover no-repeat;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #game-container {
            position: relative; /* 為了讓 game-message 絕對定位 */
            display: flex;
            flex-direction: column;
            /* ** * * 這就是修改的地方！
             * 我將 height 從 80vh 改為 100%，
             * 讓它可以填滿父層 (body) 的 100% 高度。
             * ** */
            height: 100%; 
            width: 100%;
            max-width: 1024px;
            margin: 0 auto;
            padding: 0.5rem;
            box-sizing: border-box; /* 加上 box-sizing 確保 padding 不會影響總高度 */
        }
        .central-area { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; }
        .central-area > .game-field-box { 
            flex-grow: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow: hidden; /* 新增: 確保場牌區不超過其分配的高度 */
        }
        #opponent-hand, #player-hand { transition: all 0.3s ease-in-out; }
        #opponent-hand { height: 8vh; }
        #player-hand { height: 18vh; }
        #opponent-captured, #player-captured { height: 10vh; }
        #player-hand, #opponent-hand { display: flex; justify-content: center; align-items: center; flex-wrap: nowrap; border-radius: 0.5rem; border: 2px solid transparent; }
        
        .active-turn {
            border-color: #fef08a;
            box-shadow: 0 0 15px 5px rgba(254, 240, 138, 0.5);
            background-color: rgba(254, 240, 138, 0.1) !important;
        }

        .card { border: 1px solid #555; border-radius: 8px; background-size: cover; background-position: center; background-repeat: no-repeat; cursor: pointer; transition: all 0.2s ease-in-out; user-select: none; background-color: #fff; box-shadow: inset 0 0 3px rgba(0,0,0,0.4), 2px 2px 5px rgba(0,0,0,0.3); }
        .card:hover { transform: translateY(-8px) scale(1.05); }
        .card-face-down { background-image: url('https://lingamjiji.wordpress.com/wp-content/uploads/2025/10/00_0.jpg'); background-size: cover; background-position: center; background-color: #000000; }
        .hand-card-container { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .modal { display: none; }
        .modal.active { display: flex; }
        .yaku-item { transition: all 0.3s ease; }
        .yaku-item.new { background-color: #fefcbf; transform: scale(1.05); color: #000; }
        #game-message { transition: opacity 0.5s ease; }
        
        /* **修正點**: 新增卡牌選中樣式 */
        .card.staged-card {
            transform: translateY(-20px) scale(1.1);
            box-shadow: 0 0 20px 5px rgba(252, 211, 77, 0.7); /* A bright yellow glow */
        }
        .card.staged-card:hover {
            transform: translateY(-20px) scale(1.1); /* 覆蓋普通 hover 效果 */
        }

        /* 新增: 給牌庫卡牌一個固定的尺寸 */
        #deck.card {
            width: 60px;  /* 寬度 */
            height: 90px; /* 高度 (1.5倍寬) */
        }

    </style>
</head>
<body class="bg-gray-800 text-white">

    <!-- 遊戲標題畫面 -->
    <div id="title-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center p-4 text-center">
        <div class="bg-black/60 p-8 rounded-xl shadow-2xl">
            <h1 class="text-5xl md:text-7xl font-bold text-yellow-300 tracking-wider">吉吉色色牌</h1>
            <h2 class="text-2xl md:text-3xl text-white mt-2 mb-8">台灣花牌/花札</h2>
            <div class="flex flex-col md:flex-row gap-4">
                <button id="start-game-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 text-xl rounded-lg shadow-lg transition-transform transform hover:scale-105">開始遊戲</button>
                <button id="rules-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-8 text-xl rounded-lg shadow-lg transition-transform transform hover:scale-105">遊戲說明</button>
            </div>
            <p class="text-xs text-gray-300 mt-12">靈根吉吉開運好物製販所 2025年出品</p>
        </div>
    </div>

    <!-- 遊戲主容器 (預設隱藏) -->
    <div id="game-container" class="hidden">
        <div id="game-message" class="absolute top-4 left-1/2 -translate-x-1/2 bg-black/80 p-2 px-4 rounded-lg text-lg z-30 opacity-0 pointer-events-none"></div>
        <!-- 對手區域 -->
        <div class="mb-2">
            <div class="flex items-center justify-end mb-2 px-2"> <!-- 修正: justify-between -> justify-end -->
                <!-- <h2 class="text-sm md:text-lg font-bold">對手</h2> --> <!-- 移除 -->
                <div class="flex items-center space-x-2">
                    <span id="opponent-score" class="text-lg md:text-xl font-bold">0 分</span>
                </div>
            </div>
            <div id="opponent-hand" class="p-2 bg-gray-900/50"></div>
            <div class="mt-2 p-1 bg-gray-700/50 rounded-lg">
                <div id="opponent-captured" class="flex flex-wrap gap-1 justify-center"></div>
            </div>
        </div>
        <!-- 中央區域 -->
        <div class="central-area my-2">
             <div class="game-field-box p-2 bg-green-900/60 rounded-lg border-2 border-yellow-700">
                <div id="field" class="hand-card-container flex-grow h-full"></div>
                <div class="ml-4 md:ml-8 flex flex-col items-center">
                    <!-- 順序調換：數字在上方，牌在下方 -->
                    <span id="deck-count" class="mb-2 text-lg font-semibold">48</span>
                    <div id="deck" class="card card-face-down"></div>
                </div>
             </div>
        </div>
        <!-- 玩家區域 -->
        <div class="mt-2">
             <div class="flex items-center justify-end mb-2 px-2"> <!-- 修正: justify-between -> justify-end -->
                <!-- <h2 class="text-sm md:text-lg font-bold">您</h2> --> <!-- 移除 -->
                <div class="flex items-center space-x-2">
                    <span id="player-score" class="text-lg md:text-xl font-bold">0 分</span>
                </div>
            </div>
            <div class="mt-2 p-1 bg-gray-700/50 rounded-lg">
                <div id="player-captured" class="flex flex-wrap gap-1 justify-center"></div>
            </div>
            <div id="player-hand" class="p-2 bg-gray-900/50 mt-2"></div>
        </div>
    </div>
    
    <!-- 彈出視窗 (Modal) -->
    <div id="yaku-modal" class="modal fixed inset-0 bg-black/80 items-center justify-center p-4 z-50">
        <div class="bg-gray-800 border-2 border-yellow-600 rounded-lg shadow-2xl p-6 w-full max-w-md text-center">
            <h2 id="modal-title" class="text-3xl font-bold text-yellow-300 mb-4"></h2>
            <div id="modal-yaku-list" class="space-y-2 text-left mb-6"></div>
            <div id="modal-buttons" class="flex justify-center gap-4"></div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM 元素 ---
    const titleScreen = document.getElementById('title-screen');
    const startGameButton = document.getElementById('start-game-button');
    const rulesButton = document.getElementById('rules-button');
    const gameContainer = document.getElementById('game-container');
    const playerHandEl = document.getElementById('player-hand');
    const opponentHandEl = document.getElementById('opponent-hand');
    const fieldEl = document.getElementById('field');
    const deckEl = document.getElementById('deck');
    const deckCountEl = document.getElementById('deck-count');
    const playerScoreEl = document.getElementById('player-score');
    const opponentScoreEl = document.getElementById('opponent-score');
    const playerCapturedEl = document.getElementById('player-captured');
    const opponentCapturedEl = document.getElementById('opponent-captured');
    const yakuModal = document.getElementById('yaku-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalYakuList = document.getElementById('modal-yaku-list');
    const modalButtons = document.getElementById('modal-buttons');
    const gameMessageEl = document.getElementById('game-message');

    // --- 卡片資料 ---
    const CARDS = [ { id: 1, month: 1, name: '天藍光', type: 'hikari', points: 20, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/01_1.jpg' }, { id: 2, month: 1, name: '天藍天根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/01_2.jpg' }, { id: 3, month: 1, name: '天藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/01_3.jpg' }, { id: 4, month: 1, name: '天藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/01_4.jpg' }, { id: 5, month: 2, name: '桃靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/02_1.jpg' }, { id: 6, month: 2, name: '桃天根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/02_2.jpg' }, { id: 7, month: 2, name: '桃吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/02_3.jpg' }, { id: 8, month: 2, name: '桃吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/02_4.jpg' }, { id: 9, month: 3, name: '孔雀綠光', type: 'hikari', points: 20, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/03_1.jpg' }, { id: 10, month: 3, name: '孔雀綠天根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/03_2.jpg' }, { id: 11, month: 3, name: '孔雀綠吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/03_3.jpg' }, { id: 12, month: 3, name: '孔雀綠吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/03_4.jpg' }, { id: 13, month: 4, name: '焦茶靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/04_1.jpg' }, { id: 14, month: 4, name: '焦茶人根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/04_2.jpg' }, { id: 15, month: 4, name: '焦茶吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/04_3.jpg' }, { id: 16, month: 4, name: '焦茶吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/04_4.jpg' }, { id: 17, month: 5, name: '紫藤靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/05_1.jpg' }, { id: 18, month: 5, name: '紫藤人根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/05_2.jpg' }, { id: 19, month: 5, name: '紫藤吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/05_3.jpg' }, { id: 20, month: 5, name: '紫藤吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/05_4.jpg' }, { id: 21, month: 6, name: '梔子綠靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/06_1.jpg' }, { id: 22, month: 6, name: '梔子綠地根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/06_2.jpg' }, { id: 23, month: 6, name: '梔子綠吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/06_3.jpg' }, { id: 24, month: 6, name: '梔子綠吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/06_4.jpg' }, { id: 25, month: 7, name: '山吹靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/07_1.jpg' }, { id: 26, month: 7, name: '山吹人根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/07_2.jpg' }, { id: 27, month: 7, name: '山吹吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/07_3.jpg' }, { id: 28, month: 7, name: '山吹吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/07_4.jpg' }, { id: 29, month: 8, name: '菫紫光', type: 'hikari', points: 20, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/08_1.jpg' }, { id: 30, month: 8, name: '菫紫靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/08_2.jpg' }, { id: 31, month: 8, name: '菫紫吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/08_3.jpg' }, { id: 32, month: 8, name: '菫紫吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/08_4.jpg' }, { id: 33, month: 9, name: '鉻藍靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/09_1.jpg' }, { id: 34, month: 9, name: '鉻藍地根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/09_2.jpg' }, { id: 35, month: 9, name: '鉻藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/09_3.jpg' }, { id: 36, month: 9, name: '鉻藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/09_4.jpg' }, { id: 37, month: 10, name: '水藍靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/10_1.jpg' }, { id: 38, month: 10, name: '水藍地根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/10_2.jpg' }, { id: 39, month: 10, name: '水藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/10_3.jpg' }, { id: 40, month: 10, name: '水藍吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/10_4.jpg' }, { id: 41, month: 11, name: '珊瑚紅光', type: 'hikari', points: 20, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/11_1.jpg' }, { id: 42, month: 11, name: '珊瑚紅靈', type: 'tane', points: 10, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/11_2.jpg' }, { id: 43, month: 11, name: '珊瑚紅人根', type: 'tanzaku', points: 5, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/11_3.jpg' }, { id: 44, month: 11, name: '珊瑚紅吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/11_4.jpg' }, { id: 45, month: 12, name: '黃光', type: 'hikari', points: 20, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/12_1.jpg' }, { id: 46, month: 12, name: '黃吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/12_2.jpg' }, { id: 47, month: 12, name: '黃吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/12_3.jpg' }, { id: 48, month: 12, name: '黃吉', type: 'kasu', points: 1, image: 'https://lingamjiji.com/wp-content/uploads/2024/12/12_4.jpg' }, ]; // 修正: 修正卡片48的 'httpss' 網址錯誤
    const YAKU = { goko: { name: '五光', points: 10, cards: [1, 9, 29, 41, 45], count: 5, type: 'hikari' }, shiko: { name: '四光', points: 8, cards: [1, 9, 29, 45], count: 4, type: 'hikari' }, ame_shiko: { name: '大四光', points: 7, cards: [1, 9, 29, 45, 41], includes: 41, count: 4, type: 'hikari' }, sanko: { name: '三光', points: 5, cards: [1, 9, 29, 45], count: 3, type: 'hikari' }, ino_shika_cho: { name: '雉猿犬', points: 5, cards: [21, 25, 37], count: 3, type: 'tane' }, aka_tan: { name: '天根', points: 5, names: ['天藍天根', '桃天根', '孔雀綠天根'], count: 3, type: 'tanzaku' }, ao_tan: { name: '地根', points: 5, names: ['梔子綠地根', '鉻藍地根', '水藍地根'], count: 3, type: 'tanzaku' }, tanzaku: { name: '根根', points: 1, per: 1, min: 5, type: 'tanzaku' }, tane: { name: '靈靈', points: 1, per: 1, min: 5, type: 'tane' }, kasu: { name: '吉吉', points: 1, per: 1, min: 10, type: 'kasu' }, tsukimi_zake: { name: '龍蛙來', points: 5, cards: [45, 33], count: 2 }, hanami_zake: { name: '金龍貓', points: 5, cards: [9, 33], count: 2 }, };
    let gameState = {};
    
    // --- 遊戲邏輯函式 ---
    // **修正點**: 新增 selectedCardIndex 狀態
    const createNewGameState = () => ({ deck: [], player: { hand: [], captured: [], score: 0, yaku: {} }, opponent: { hand: [], captured: [], score: 0, yaku: {} }, field: [], currentPlayer: 'player', isTurnInProgress: false, roundOver: false, selectedCardIndex: null });
    
    const initGame = () => {
        gameState = createNewGameState();
        startRound();
    };

    const startRound = () => {
        gameState.deck = [...CARDS].sort(() => Math.random() - 0.5);
        ['player', 'opponent'].forEach(p => {
            gameState[p].hand = []; gameState[p].captured = []; gameState[p].yaku = {}; gameState[p].score = 0;
        });
        gameState.field = [];
        gameState.roundOver = false;
        gameState.selectedCardIndex = null;
        for (let i = 0; i < 8; i++) {
            if (gameState.deck.length > 0) gameState.player.hand.push(gameState.deck.pop());
            if (gameState.deck.length > 0) gameState.opponent.hand.push(gameState.deck.pop());
            if (gameState.deck.length > 0) gameState.field.push(gameState.deck.pop());
        }
        checkInitialField();
        if (!gameState.roundOver) {
            renderAll();
            playerHandEl.classList.add('active-turn');
            opponentHandEl.classList.remove('active-turn');
            gameState.currentPlayer = 'player';
        }
    };

    const showGameMessage = (text, persistent = false) => { gameMessageEl.textContent = text; gameMessageEl.classList.remove('opacity-0'); if (!persistent) { setTimeout(() => { gameMessageEl.classList.add('opacity-0'); }, 2000); } };
    const hideGameMessage = () => gameMessageEl.classList.add('opacity-0');

    const showFinalScoreModal = (winner, points) => {
        modalTitle.textContent = '本局結束';
        let message = winner ? `${winner === 'player' ? '您' : '對手'}贏了此局，獲得 ${points} 分！` : '此局平手。';
        modalYakuList.innerHTML = `<p class="text-xl text-center">${message}</p>`;
        modalButtons.innerHTML = '';
        const gameOverButton = document.createElement('button');
        gameOverButton.textContent = '遊戲結束';
        gameOverButton.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded';
        gameOverButton.onclick = () => { yakuModal.classList.remove('active'); goToTitleScreen(); };
        modalButtons.appendChild(gameOverButton);
        yakuModal.classList.add('active');
    };

    const endRound = (winner, points) => {
        if (gameState.roundOver) return;
        gameState.roundOver = true;
        playerHandEl.classList.remove('active-turn');
        opponentHandEl.classList.remove('active-turn');
        let finalWinner = winner, finalPoints = points;
        if (!finalWinner) {
            const playerScore = gameState.player.score; const opponentScore = gameState.opponent.score;
            if (playerScore > opponentScore) { finalWinner = 'player'; finalPoints = playerScore; } 
            else if (opponentScore > playerScore) { finalWinner = 'opponent'; finalPoints = opponentScore; }
        }
        if (finalWinner) gameState[finalWinner].score = finalPoints;
        updateScores();
        showFinalScoreModal(finalWinner, finalPoints);
    };

    const endTurn = () => {
        if (gameState.roundOver) return;
        if (gameState.player.hand.length === 0 || gameState.deck.length === 0) { endRound(null, 0); return; }
        gameState.isTurnInProgress = false;
        gameState.currentPlayer = gameState.currentPlayer === 'player' ? 'opponent' : 'player';
        if (gameState.currentPlayer === 'player') {
            playerHandEl.classList.add('active-turn');
            opponentHandEl.classList.remove('active-turn');
        } else {
            opponentHandEl.classList.add('active-turn');
            playerHandEl.classList.remove('active-turn');
            setTimeout(opponentTurn, 1000);
        }
    };
    
    // **修正點**: onPlayerCardClick 函式
    const onPlayerCardClick = function(event) {
        if (gameState.currentPlayer !== 'player' || gameState.isTurnInProgress || gameState.roundOver) return;
        const clickedIndex = parseInt(event.currentTarget.dataset.handIndex);

        if (gameState.selectedCardIndex === clickedIndex) {
            gameState.isTurnInProgress = true;
            gameState.selectedCardIndex = null;
            const playedCard = gameState.player.hand[clickedIndex];
            gameState.player.hand.splice(clickedIndex, 1);
            processCardPlay('player', playedCard);
        } else {
            gameState.selectedCardIndex = clickedIndex;
            renderHand(gameState.player.hand, playerHandEl, 'player');
        }
    };
    
    // **修正點**: renderHand 函式
    const renderHand = function(hand, element, owner) {
        element.innerHTML = '';
        const isOpponent = owner === 'opponent';
        const isHandArea = (owner === 'player' || owner === 'opponent');
        const cardSize = calculateCardSize(element, hand.length, isHandArea);
        hand.sort((a,b) => a.month - b.month).forEach((card, index) => {
            const cardEl = createCardElement(card, owner, isOpponent);
            cardEl.style.width = `${cardSize.width}px`;
            cardEl.style.height = `${cardSize.height}px`;
            if (isHandArea && cardSize.overlap > 0 && index > 0) { cardEl.style.marginLeft = `-${cardSize.overlap}px`; }
            cardEl.dataset.handIndex = index;
            if (owner === 'player') {
                cardEl.addEventListener('click', onPlayerCardClick);
                if (gameState.selectedCardIndex === index) {
                    cardEl.classList.add('staged-card');
                }
            }
            element.appendChild(cardEl);
        });
    };

    const processCardPlay = async function(player, playedCard) { hideGameMessage(); const matchingFieldCards = gameState.field.filter(c => c.month === playedCard.month); if (matchingFieldCards.length === 0) { gameState.field.push(playedCard); renderField(gameState.field, fieldEl); await new Promise(resolve => setTimeout(resolve, 500)); drawFromDeck(player); } else if (matchingFieldCards.length === 1) { const fieldCard = matchingFieldCards[0]; captureCards(player, [playedCard, fieldCard]); await new Promise(resolve => setTimeout(resolve, 500)); drawFromDeck(player); } else { if (player === 'player') { highlightMatches(matchingFieldCards); showGameMessage('請選擇一張要配對的牌。', true); gameState.pendingPlayedCard = playedCard; } else { const fieldCard = matchingFieldCards[Math.floor(Math.random() * matchingFieldCards.length)]; captureCards('opponent', [playedCard, fieldCard]); await new Promise(resolve => setTimeout(resolve, 500)); drawFromDeck('opponent'); } } };
    const onFieldCardClick = function(event) { if (!gameState.pendingPlayedCard || gameState.currentPlayer !== 'player' || gameState.roundOver) return; const clickedCardId = parseInt(event.currentTarget.dataset.cardId); const playedCard = gameState.pendingPlayedCard; const clickedCard = gameState.field.find(c => c.id === clickedCardId); if (clickedCard && clickedCard.month === playedCard.month) { hideGameMessage(); captureCards('player', [playedCard, clickedCard]); gameState.pendingPlayedCard = null; unhighlightAll(); setTimeout(() => drawFromDeck('player'), 500); } };
    const checkInitialField = function() { const monthCounts = gameState.field.reduce((acc, card) => { acc[card.month] = (acc[card.month] || 0) + 1; return acc; }, {}); for(const month in monthCounts) { if (monthCounts[month] === 4) { gameState.roundOver = true; showGameMessage(`場上有4張同月牌，此局無效，重新開始。`); setTimeout(initGame, 3000); return; } } }
    const renderAll = function() { if (!gameState || !gameState.player) return; renderHand(gameState.player.hand, playerHandEl, 'player'); renderHand(gameState.opponent.hand, opponentHandEl, 'opponent'); renderField(gameState.field, fieldEl); renderCaptured(gameState.player.captured, playerCapturedEl); renderCaptured(gameState.opponent.captured, opponentCapturedEl); updateScores(); deckCountEl.textContent = gameState.deck.length; }
    const createCardElement = function(card, owner = '', isFaceDown = false) { const cardEl = document.createElement('div'); if (isFaceDown) { cardEl.className = 'card card-face-down'; return cardEl; } cardEl.className = 'card'; cardEl.dataset.cardId = card.id; cardEl.dataset.owner = owner; cardEl.style.backgroundImage = `url(${card.image})`; const img = new Image(); img.src = card.image; img.onerror = () => { cardEl.innerHTML = `<div class="text-xs text-black text-center p-1">${card.name}</div>`; cardEl.style.backgroundImage = ''; cardEl.style.backgroundColor = '#ddd'; }; return cardEl; }
    
    // ** 函式修改 **
    // 採用新的「強制兩排」邏輯來計算場牌尺寸
    const calculateCardSize = (element, cardCount, isStack = false) => { 
        if (cardCount === 0) return { width: 0, height: 0, overlap: 0 }; 
        const containerWidth = element.clientWidth; 
        const containerHeight = element.clientHeight; 
        const aspectRatio = 1.5; 
        const gap = 8; 
        
        if (containerWidth === 0 || containerHeight === 0) { 
            return { width: 60, height: 90, overlap: 0 }; 
        } 
        
        if (isStack) { 
            let cardHeight = containerHeight * 0.95; 
            let cardWidth = cardHeight / aspectRatio; 
            let overlap = 0; 
            const totalWidth = cardCount * cardWidth; 
            if (totalWidth > containerWidth && cardCount > 1) { 
                overlap = (totalWidth - containerWidth) / (cardCount - 1); 
            } 
            return { width: cardWidth, height: cardHeight, overlap: Math.max(0, overlap) }; 
        } else {
            // --- 1. 檢查是否能用「單排」並「佔滿高度」來顯示 ---
            // (適用於卡牌很少的情況)
            let h1 = containerHeight - gap; // 使用 (幾乎) 全部的高度
            if (h1 < 20) h1 = 20;
            let w1 = h1 / aspectRatio;
            
            if (w1 > 15) { // 確保卡牌寬度是合理的
                let cols1 = Math.floor((containerWidth + gap) / (w1 + gap));
                if (cols1 === 0) cols1 = 1;
                
                if (cardCount <= cols1) {
                    // 卡牌很少，全部放一排，尺寸最大化
                    return { width: w1, height: h1, overlap: 0 };
                }
            }

            // --- 2. 如果單排塞不下，強制採用「兩排」佈局 ---
            const maxRows = 2;
            
            // 計算「基於高度」的尺寸 (假設我們填滿高度，分成兩排)
            const h_from_height = (containerHeight - (maxRows - 1) * gap) / maxRows;
            const w_from_height = h_from_height / aspectRatio;

            // 計算「基於寬度」的尺寸 (假設我們必須塞入 N/2 張卡牌)
            const cols_needed = Math.max(Math.ceil(cardCount / maxRows), 1); // 至少 1 欄
            
            let w_from_width = (containerWidth - (cols_needed - 1) * gap) / cols_needed;
            
            // 處理邊界情況 (例如容器太窄)
            if (w_from_width <= 0) {
                 w_from_width = (containerWidth / cols_needed) * 0.9; // 退一步，使用 90% 空間
            }
            
            const h_from_width = w_from_width * aspectRatio;

            // --- 3. 決定最終尺寸 ---
            // 真正的尺寸，受限於「高度」和「寬度」兩者中 *較小* 的那個
            // 如果 h_from_width 比較小，代表「寬度不夠」，我們受限於寬度
            // 如果 h_from_height 比較小，代表「高度不夠」，我們受限於高度
            
            if (h_from_width < h_from_height) {
                // 寬度是限制因素
                return { width: w_from_width, height: h_from_width, overlap: 0 };
            } else {
                // 高度是限制因素
                return { width: w_from_height, height: h_from_height, overlap: 0 };
            }
        } 
    };
    
    const renderField = function(field, element) { element.innerHTML = ''; const cardSize = calculateCardSize(element, field.length); field.sort((a,b) => a.month - b.month).forEach(card => { const cardEl = createCardElement(card, 'field'); cardEl.style.width = `${cardSize.width}px`; cardEl.style.height = `${cardSize.height}px`; cardEl.addEventListener('click', onFieldCardClick); element.appendChild(cardEl); }); }
    const renderCaptured = function(captured, element) { element.innerHTML = ''; const cardSize = calculateCardSize(element, captured.length); captured.sort((a,b) => b.points - a.points || a.month - b.month).forEach(card => { const cardEl = createCardElement(card, 'captured'); cardEl.style.width = `${cardSize.width}px`; cardEl.style.height = `${cardSize.height}px`; element.appendChild(cardEl); }); }
    const updateScores = function() { playerScoreEl.textContent = `${gameState.player.score} 分`; opponentScoreEl.textContent = `${gameState.opponent.score} 分`; }
    const highlightMatches = function(cardsToHighlight) { const fieldCards = fieldEl.querySelectorAll('.card'); fieldCards.forEach(el => { const id = parseInt(el.dataset.cardId); if (cardsToHighlight.some(c => c.id === id)) { el.classList.add('selected', 'border-4', 'border-yellow-400'); } else { el.classList.add('opacity-50'); } }); }
    const unhighlightAll = function() { fieldEl.querySelectorAll('.card').forEach(el => { el.classList.remove('selected', 'border-4', 'border-yellow-400', 'opacity-50'); }); }
    const drawFromDeck = async function(player) { if (gameState.deck.length === 0) { endTurn(); return; } const drawnCard = gameState.deck.pop(); deckCountEl.textContent = gameState.deck.length; const deckRect = deckEl.getBoundingClientRect(); const drawnCardEl = createCardElement(drawnCard); drawnCardEl.style.position = 'absolute'; drawnCardEl.style.left = `${deckRect.left}px`; drawnCardEl.style.top = `${deckRect.top}px`; document.body.appendChild(drawnCardEl); await new Promise(resolve => setTimeout(resolve, 100)); const fieldRect = fieldEl.getBoundingClientRect(); drawnCardEl.style.transition = 'all 0.5s ease'; drawnCardEl.style.left = `${fieldRect.x + fieldRect.width / 2 - 30}px`; drawnCardEl.style.top = `${fieldRect.y + fieldRect.height / 2 - 45}px`; await new Promise(resolve => setTimeout(resolve, 500)); drawnCardEl.remove(); const matchingFieldCards = gameState.field.filter(c => c.month === drawnCard.month); if (matchingFieldCards.length === 0) { gameState.field.push(drawnCard); renderField(gameState.field, fieldEl); } else { if(matchingFieldCards.length === 3) { captureCards(player, [drawnCard, ...matchingFieldCards]); } else { const fieldCard = matchingFieldCards[0]; captureCards(player, [drawnCard, fieldCard]); } } renderAll(); await new Promise(resolve => setTimeout(resolve, 500)); const yakuResult = checkYaku(player); if (yakuResult.newYaku.length > 0) { showYakuModal(player, yakuResult); } else { endTurn(); } }
    const captureCards = function(player, cards) { cards.forEach(card => { gameState[player].captured.push(card); const fieldIndex = gameState.field.findIndex(c => c.id === card.id); if (fieldIndex > -1) { gameState.field.splice(fieldIndex, 1); } }); renderCaptured(gameState[player].captured, player === 'player' ? playerCapturedEl : opponentCapturedEl); renderField(gameState.field, fieldEl); }
    const checkYaku = function(player) { const captured = gameState[player].captured; const currentYaku = gameState[player].yaku; const newYaku = []; let totalPoints = 0; const capturedHikari = captured.filter(c => c.type === 'hikari'); const capturedTane = captured.filter(c => c.type === 'tane'); const capturedTanzaku = captured.filter(c => c.type === 'tanzaku'); const capturedKasu = captured.filter(c => c.type === 'kasu'); let tempYaku = {}; if (capturedHikari.length >= 3) { const hasRainman = capturedHikari.some(c => c.id === 41); if (capturedHikari.length === 5) tempYaku.goko = YAKU.goko; else if (capturedHikari.length === 4 && !hasRainman) tempYaku.shiko = YAKU.shiko; else if (capturedHikari.length === 4 && hasRainman) tempYaku.ame_shiko = YAKU.ame_shiko; else if (capturedHikari.length === 3 && !hasRainman) tempYaku.sanko = YAKU.sanko; } const inoshikachoIds = YAKU.ino_shika_cho.cards; if (inoshikachoIds.every(id => captured.some(c => c.id === id))) tempYaku.ino_shika_cho = YAKU.ino_shika_cho; const akatanNames = YAKU.aka_tan.names; if (akatanNames.every(name => captured.some(c => c.name === name))) tempYaku.aka_tan = YAKU.aka_tan; const aotanNames = YAKU.ao_tan.names; if (aotanNames.every(name => captured.some(c => c.name === name))) tempYaku.ao_tan = YAKU.ao_tan; if (YAKU.hanami_zake.cards.every(id => captured.some(c => c.id === id))) tempYaku.hanami_zake = YAKU.hanami_zake; if (YAKU.tsukimi_zake.cards.every(id => captured.some(c => c.id === id))) tempYaku.tsukimi_zake = YAKU.tsukimi_zake; if (capturedTanzaku.length >= 5) tempYaku.tanzaku = {...YAKU.tanzaku, points: capturedTanzaku.length - 4}; if (capturedTane.length >= 5) tempYaku.tane = {...YAKU.tane, points: capturedTane.length - 4}; if (capturedKasu.length >= 10) tempYaku.kasu = {...YAKU.kasu, points: capturedKasu.length - 9}; if (tempYaku.goko) { delete tempYaku.shiko; delete tempYaku.ame_shiko; delete tempYaku.sanko; } if (tempYaku.shiko || tempYaku.ame_shiko) { delete tempYaku.sanko; } if (tempYaku.aka_tan || tempYaku.ao_tan) { delete tempYaku.tanzaku; } if (tempYaku.ino_shika_cho) { delete tempYaku.tane; } for (const key in tempYaku) { totalPoints += tempYaku[key].points; if (!currentYaku[key]) newYaku.push(tempYaku[key]); } gameState[player].yaku = tempYaku; gameState[player].score = totalPoints; return { newYaku, totalPoints }; }
    const showYakuModal = function(player, yakuResult) { const { newYaku, totalPoints } = yakuResult; modalTitle.textContent = player === 'player' ? '達成新組合！' : '對手達成新組合！'; modalYakuList.innerHTML = ''; for(const key in gameState[player].yaku) { const yaku = gameState[player].yaku[key]; const isNew = newYaku.some(ny => ny.name === yaku.name); const div = document.createElement('div'); div.className = `yaku-item p-2 rounded flex justify-between items-center ${isNew ? 'new' : ''}`; div.innerHTML = `<span>${yaku.name}</span> <span class="font-bold">${yaku.points} 分</span>`; modalYakuList.appendChild(div); } const totalDiv = document.createElement('div'); totalDiv.className = 'mt-4 pt-2 border-t border-gray-600 flex justify-between items-center text-xl'; totalDiv.innerHTML = `<span>總計</span> <span class="font-bold text-yellow-300">${totalPoints} 分</span>`; modalYakuList.appendChild(totalDiv); modalButtons.innerHTML = ''; if (player === 'player') { const koiButton = document.createElement('button'); koiButton.textContent = '繼續'; koiButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded'; koiButton.onclick = () => { yakuModal.classList.remove('active'); showGameMessage('您選擇了繼續！'); endTurn(); }; const stopButton = document.createElement('button'); stopButton.textContent = '結束此回合'; stopButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded'; stopButton.onclick = () => { yakuModal.classList.remove('active'); endRound(player, totalPoints); }; modalButtons.append(koiButton, stopButton); } else { const opponentChoice = opponentAIChoice(totalPoints); const choiceText = document.createElement('p'); choiceText.className = "text-lg italic mt-4"; choiceText.textContent = `對手決定 "${opponentChoice === 'koi' ? '繼續' : '結束此回合'}"...`; modalButtons.appendChild(choiceText); setTimeout(() => { yakuModal.classList.remove('active'); if(opponentChoice === 'koi') { showGameMessage('對手選擇了繼續！'); endTurn(); } else { endRound('opponent', totalPoints); } }, 2000); } yakuModal.classList.add('active'); }
    const opponentTurn = function() { if (gameState.roundOver || gameState.isTurnInProgress) return; gameState.isTurnInProgress = true; const hand = gameState.opponent.hand; const field = gameState.field; let bestMatch = null; for (let i = 0; i < hand.length; i++) { const handCard = hand[i]; const matches = field.filter(fc => fc.month === handCard.month); if (matches.length > 0) { matches.sort((a,b) => b.points - a.points); const currentMatchValue = handCard.points + matches[0].points; if (!bestMatch || currentMatchValue > bestMatch.value) { bestMatch = { handCard, fieldCard: matches[0], value: currentMatchValue, handIndex: i }; } } } let playedCard; let handIndex; if (bestMatch) { playedCard = bestMatch.handCard; handIndex = bestMatch.handIndex; } else { handIndex = Math.floor(Math.random() * hand.length); playedCard = hand[handIndex]; } gameState.opponent.hand.splice(handIndex, 1); renderHand(gameState.opponent.hand, opponentHandEl, 'opponent'); processCardPlay('opponent', playedCard); }
    const opponentAIChoice = function(points) { if (points >= 7) return 'stop'; if (points >= 5 && Math.random() > 0.4) return 'stop'; if (gameState.deck.length < 10 && points > 3) return 'stop'; return 'koi'; }
    
    const goToTitleScreen = () => {
        gameContainer.classList.add('hidden');
        titleScreen.classList.remove('hidden');
    }

    // --- 按鈕事件監聽 ---
    startGameButton.addEventListener('click', () => {
        titleScreen.classList.add('hidden');
        gameContainer.classList.remove('hidden');
        initGame();
    });

    rulesButton.addEventListener('click', () => {
        window.open('https://lingamjiji.com/shop/shop06/', '_blank');
    });

    // --- 響應式調整 ---
    let debounceTimer;
    const debounce = (func, delay) => { return (...args) => { clearTimeout(debounceTimer); debounceTimer = setTimeout(() => func.apply(this, args), delay); }; };
    const debouncedRender = debounce(renderAll, 200);
    window.addEventListener('resize', debouncedRender);

});
</script>

</body>
</html>



